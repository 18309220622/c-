#include<iostream>
#include<vector>
using namespace std;
//1.实现一个位图
class BitMap
{
public:
	BitMap(const size_t& range)
	{
		_bitmap.resize((range >> 5) + 1);   //将size置为要求的空间大小
	}
	void Set(const size_t& x)    //设置状态为1
	{
		size_t index = x >> 5;   //计算哪一字节
		size_t num = x % 32;     //计算哪一位
		_bitmap[index] |= (1 << num);
	}
	void ReSet(const size_t& x)   //进行复位
	{
		size_t index = x >> 5;
		size_t num = x % 32;
		_bitmap[index] &= (~(1<<num));
	}
	bool Test(const size_t& x)   //判定位的状态
	{
		size_t index = x >> 5;
		size_t num = x % 32;
		return _bitmap[index] & (1 << num);
	}
private:
	vector<size_t> _bitmap;
};

int main()
{
	BitMap bt(111111);
	bt.Set(1);
	bt.Set(5);
	bt.Set(111);
	//bt.ReSet(1);

	cout << bt.Test(1) << endl;
	cout << bt.Test(111) << endl;
	cout << bt.Test(122) << endl;
	system("pause");
	return 0;
}
//2.以下三个问题都是位图相关类似题目，请给出解决方案：
//（1）给定100亿个整数，设计算法找到只出现一次的整数
//只出现一次的整数，这就表明数据有三种状态：不存在，出现一次，出现一次以上的；
//这时我们可以用两个比特位来表示数据的状态，00表示不存在，01表示出现一次，10表示出现一次以上的
//11表示无意义。这样占用内存大约就是2.5GB多一点，对于现在的普通计算机来说是可以处理这个问题的。

//（2）给两个文件，分别有100亿个整数，我们只有1G内存，如何找到两个文件交集
//这里可以采用哈希切分的思想，这并不是均分的(如果切分为100份的话，分别加载进A的一份和B的一份
//可能1GB的内存就存不下了)，100亿个整数可以切分为1000个文件，两个大文件A,B就切分成了2000个小
//文件，然后我们进行相同的哈希算法，A的100亿个数对1000进行取模后，操作后，根据余数不同，对应
//存在A0文件 - A999文件，这样就完成了A的哈希切分，然后我们对B进行哈希切分，同样的思想，分出
//1000个文件，根据余数的不同分配到B0 - B999文件中，最后我们将对应编号的文件加载进内存做比对。
//这样就能找到两个文件的交集（相同的数经过同一哈希算法将会进入同一编号的文件里）。

//（3）1个文件有100亿个int，1G内存，设计算法找到出现次数不超过2次的所有整数
//次数不超过2次，这里就告诉我们数据的状态有：不存在，出现一次，出现两次，出现两次以上
//所以我们可以用两个比特位来表示，00不存在，01出现一次，10出现两次，11出现两次以上
//其实所有的int类型总共也就四十二亿九千万之多的比特位，如果用两个比特位来表示数据状态的话也就
//占用内存1GB,刚好符合题意，然后我们找到对应状态的数，统计出来就好了。